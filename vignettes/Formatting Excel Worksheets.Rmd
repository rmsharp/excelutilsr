---
title: "Formatting Excel Worksheets with R"
author: "R. Mark Sharp, Ph.D."
date: "March 6, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(XLConnect))
library(stringi)
library(excelutilsr)

```
Though I try to not send data to individuals within an Excel file, 
sometimes my colleagues use Excel extensively in their own work, 
are adept at using Excel, and benefit from some of the formatting that is 
available for highlighting specific cells, columns, and rows within worksheets. 
For these reasons, I have put together a small function to encapsulate many 
of the nice formatting features provided by the XLConnect 
<a href="mailto:xlconnect@mirai-solutions.com">xlconnect@mirai-solutions.com</a>
package, which is available on CRAN.

The function `add_formatted_worksheet` is used on one worksheet at a time, but 
can add any number of formats to different cells within that worksheet. 
An example or two will make the process clear.

Let's say you are a teacher who has given your students three different ways to
earn points for the class you are teaching. They are listed below:

Type        | Number Possible | Percent of Final Grade
------------|-----------------|-----------------------
Excercise   |       10        |            30
Exam        |        4        |            40
Final       |        1        |            30

You want to provide yourself and your students with a way of glancing at their
grades and knowing where they stand quickly so you devise a plan to indicate 
how things are going by using 
Excel's formatting tools.

1. Excercises are in cells with an unlined left and right borders.
2. Exams are in cells with a single lined left and right borders.
3. The final has a double lined left and right borders.
1. Individual grades below 65 have a red foreground.
2. Individual grades below 75 have a yellow foreground.
3. Grades of 75 and above are in a transparent clear foreground.
3. The cells with the student names of individuals with cumulative scores 
that are equal to or above 75 have a green foreground.
4. The cells with the student names of individuals with cumulative scores 
that are greater than or equal to 65 and below 75 have a 
yellow foreground. 
5. The cells with the student names of individuals with cumulative scores 
that are below 65 have a red foreground. 

We can start by identifying the columns of cells with Exam grades. Let's say
the column names are of the form "Exam_1" or "Week_2_Exam" such that we can 
use the string "exam" to identify the correct columns. The function could be 
written as follows. 

```{r echo = TRUE, include = TRUE}
is_exam <- function(df) {
  sapply(names(df), function(col_name) {
    if (stri_detect_regex(tolower(col_name), pattern = "exam") &
        !stri_detect_regex(tolower(col_name), pattern = "final")) {
      rep(TRUE, nrow(df))
    } else {
      rep(FALSE, nrow(df))
    }
  })
}
```
I have created a small dataframe containing some imaginary students and grades
that can be used to illustrate the various functions.
```{r echo = TRUE, include = TRUE}
grade_df <- data.frame(Student = c("James", "Jane", "Jamie"), 
                      "Exam_1" = c(86, 35, 42),
                      "Exercise_1" = c(75, 0, 95),
                      "Exercise_2" = c(100, 65, 80),
                      "Exam 2" = c(92, 49, 59), 
                      "Final Exam" = c(84, 68, 95),stringsAsFactors = FALSE)
is_exam(grade_df)

```
It is now easy to come up with a function that detects the column with
the string "final" or "exercise" embedded in the column name.

```{r echo = TRUE, include = TRUE}
is_final <- function(df) {
  sapply(names(df), function(col_name) {
    if (stri_detect_regex(tolower(col_name), pattern = "final")) {
      rep(TRUE, nrow(df))
    } else {
      rep(FALSE, nrow(df))
    }
  })
}
is_final(grade_df)
is_exercise <- function(df) {
  sapply(names(df), function(col_name) {
    if (stri_detect_regex(tolower(col_name), pattern = "exercise")) {
      rep(TRUE, nrow(df))
    } else {
      rep(FALSE, nrow(df))
    }
  })
}
is_exercise(grade_df)

```
In an equivalent way we can write a function to see if a cell holds a
student's name. 
```{r echo = TRUE, include = TRUE}
is_student <- function(df) {
  sapply(names(df), function(col_name) {
    if (stri_detect_regex(tolower(col_name), pattern = "student")) {
      rep(TRUE, nrow(df))
    } else {
      rep(FALSE, nrow(df))
    }
  })
}
is_student(grade_df)

```
Testing for individual cell values is a bit different, but using _R's_ vectors
makes it quite simple. Thus, to test for individual grades below 65 we use
the following function
```{r echo = TRUE, include = TRUE}
is_score_below_65 <- function(grade_df) {grade_df < 65}
is_score_below_65(grade_df)

```
After seeing how simply that was constructed, the next two functions we need are 
easily written with the one complexity of how to handle grades below 75 and 
not less than 65.

```{r echo = TRUE, include = TRUE}
is_score_equal_or_above_65_and_below_75 <- function(grade_df) {
  grade_df < 75 &
  !grade_df < 65
}
is_score_equal_or_above_65_and_below_75(grade_df)

is_score_equal_or_above_75 <- function(grade_df) {grade_df >= 75}

is_score_equal_or_above_75(grade_df)

```
When calculating current averages, scores have to take into account order and 
weight of the scores. 
We can do this by calculating possible total points up to the 
current cell. I am choosing to put my knowledge of the number and value of each
type of grade into a single function (`get_grading_scheme()`). 
`r stri_c(" _", unlist(stri_split_fixed("Handling excussed missing grades is outside the scope of this example", " ")), "_", collapse = "")`.
```{r echo = TRUE, include = TRUE}
#' Grading scheme

#' This function houses the number of each grade type and the points assigned 
#' to those grade types.
#'
get_grading_scheme <- function() {
  list(n_exams = 4,
       exam_pts = 40.0,
       n_exercises = 10,
       exercise_pts = 30.0,
       n_finals = 1,
       final_pts = 30.0,
       total_pts = 100)
}
```
```{r echo = TRUE, include = TRUE}

#' Looks at the number of exercises, exams, and finals complete to return the
#' maximum number of points that could have been earned by the student at
#' any specific point.
get_individual_possible_pts <- function(exercises = 10, exams = 4, finals = 1) {
  sched <- get_grading_scheme()
  exercises / sched$n_exercises * sched$exercise_pts  + 
    exams / sched$n_exams * sched$exam_pts  + 
    finals / sched$n_finals * sched$final_pts
}
get_student_col <- function(df) {
  col_names <- names(df)
  (1:length(df))[
    stri_detect_regex(tolower(col_names), pattern = "student")]
}
#' Looks at the number of exercises, exams, and finals complete to return the
#' maximum number of points that could have been earned by the student at
#' any specific point.
get_possible_pts <- function(grade_df) {
  student_col <- get_student_col(grade_df)
  possible_pts <- data.frame()
  for (row in 1:nrow(grade_df)) { # students are on rows
    exercises <- 0
    exams <- 0
    finals <- 0
    values <- numeric(ncol(grade_df) - 1)
    pts <- 0
    for (col in 1:ncol(grade_df)) {
      if (col == student_col) {
        next
      } else if (is_exercise(grade_df)[row, col]) {
        exercises <- exercises + 1
        values[col] <- get_individual_possible_pts(exercises, exams, finals)
      } else if (is_exam(grade_df)[row, col]) {
        exams <- exams + 1
        values[col] <- get_individual_possible_pts(exercises, exams, finals)
      } else if (is_final(grade_df)[row, col]) {
        finals <- finals + 1
        values[col] <- get_individual_possible_pts(exercises, exams, finals)
      }
    }
    possible_pts <- rbind(possible_pts,  values)
  }
  
  names(possible_pts) <- names(grade_df)
  possible_pts <- possible_pts[ , -student_col]
  possible_pts <- cbind(grade_df[ , names(grade_df)[
    stri_detect_regex(tolower(names(grade_df)), "student")]], 
                        possible_pts)
  possible_pts
}

get_earned_pts <- function(grade_df) {
  sched <- get_grading_scheme()
  student_col <- get_student_col(grade_df)
  partial_df <- grade_df[ , -student_col]
  exam_df <- partial_df * is_exam(partial_df) * 
    sched$exam_pts / (sched$n_exams * sched$total_pts)
  exercise_df <- partial_df * is_exercise(partial_df) * 
    sched$exercise_pts / (sched$n_exercises * sched$total_pts)
  final_df <- partial_df * is_final(partial_df) * 
    sched$final_pts / (sched$n_finals * sched$total_pts)
  current_grade_df <- exam_df + exercise_df + final_df
  t_df <- data.frame(grade_df[ , student_col], current_grade_df)
  names(t_df) <- names(grade_df)
  t_df
}
get_cummulative_earned_pts <- function(df) {
  student_col <- get_student_col(df)
  t_df <- get_earned_pts(df)
  c_pts <- t(cumsum(data.frame(as.matrix(t(t_df[ , -student_col]), 
                                         ncol = nrow(df)))))
  c_pts <- data.frame(df[ , student_col], c_pts, check.names = FALSE, 
                      stringsAsFactors = FALSE, row.names = NULL)
  names(c_pts) <- names(df)
  c_pts
}
get_current_avg <- function(df) {
  student_col <- get_student_col(df)
  possible_points <- get_possible_pts(df)
  earned_points <- get_cummulative_earned_pts(df) # needs to be cumulative earned points
  current_avg <- earned_points[ , -student_col] / possible_points[ , -student_col]
  current_avg <- data.frame(earned_points[ , student_col], current_avg)
  names(current_avg) <- names(df)
  current_avg
}

current_avg <- get_current_avg(grade_df)
```
Thus, for the function `is_avg_equal_or_above_75()` 

```{r echo = TRUE, include = TRUE}
is_avg_equal_or_above_75 <- function(grade_df) {
  is_score_equal_or_above_75(get_current_avg(grade_df))
}
```
Identical strategy is used for both `is_avg_below_65()` and 
`is_avg_equal_or_above_65_and_below_75()`.

```{r echo = TRUE, include = TRUE}
is_avg_below_65 <- function(grade_df) {
  is_score_below_65(get_current_avg(grade_df))
}

is_avg_equal_or_above_65_and_below_75 <- function(grade_df) {
  is_score_equal_or_above_65_and_below_75(get_current_avg(grade_df))
}
```
I have created a small dataframe containing some imaginary students and grades.
```{r echo = TRUE, include = TRUE}
make_df_with_FALSE <- function(current_avg) {
  data.frame(matrix(rep(FALSE, nrow(current_avg) *
                          (max(col(current_avg)) - 1)), 
                    nrow = nrow(current_avg),
                    ncol = ncol(current_avg) - 1))
}
add_student_col <- function(current_avg, score_test_col, student_col) {
  false_col <- rep(FALSE, nrow(current_avg))
  student_df <- data.frame(false_col)
  for (col in seq_along(current_avg)) {
    if (col != student_col) {
      student_df <- data.frame(student_df, false_col)
    } else {
      student_df <-data.frame(student_df, student = score_test_col)
    }
  }
  student_df <- student_df[ , -1]
  names(student_df) <- names(current_avg)
  student_df
}
student_avg_test <- function(grade_df, score_test) {
  if (nrow(grade_df) == 0) {
    return(NA)
  }
  current_avg <- get_current_avg(grade_df)
  student_col <- get_student_col(current_avg)
  score_test_col <- logical(nrow(grade_df))
  for (row in 1:nrow(grade_df)) {
    max_col <- max(col(current_avg[row, ] & !is.na(grade_df[row, ])))
    if (score_test(current_avg[row, max_col])) {
      score_test_col[row] <- TRUE
    } else {
      score_test_col[row] <- FALSE
    }
  }
  student_df <- add_student_col(current_avg, score_test_col, 
                                student_col)
  student_df
}
# student_avg_below_65 <- function(grade_df) {
#   if (nrow(grade_df) == 0) {
#     return(NA)
#   }
#   current_avg <- get_current_avg(grade_df)
#   student_col <- get_student_col(current_avg)
#   below_65 <- logical(nrow(grade_df))
#   for (row in 1:nrow(grade_df)) {
#     max_col <- max(col(current_avg[row, ] & !is.na(grade_df[row, ])))
#     if (current_avg[row, max_col] < 65) {
#       below_65[row] <- TRUE
#     } else {
#       below_65[row] <- FALSE
#     }
#   }
#   student_df <- add_student_col(current_avg, below_65, student_col)
#   student_df
# }

# student_avg_below_75_and_above_65 <- function(grade_df) {
#   if (nrow(grade_df) == 0) {
#     return(NA)
#   }
#   current_avg <- get_current_avg(grade_df)
#   student_col <- get_student_col(current_avg)
#   between_75_and_65 <- logical(nrow(grade_df))
#   for (row in 1:nrow(grade_df)) {
#     max_col <- max(col(current_avg[row, ] & !is.na(grade_df[row, ])))
#     if (current_avg[row, max_col] < 75 &
#         !current_avg[row, max_col] < 65) {
#       between_75_and_65[row] <- TRUE
#     } else {
#       between_75_and_65[row] <- FALSE
#     }
#   }
#   student_df <- add_student_col(current_avg, between_75_and_65, 
#                                 student_col)
#   student_df
# }
# student_avg_equal_or_above_75 <- function(grade_df) {
#   if (nrow(grade_df) == 0) {
#     return(NA)
#   }
#   current_avg <- get_current_avg(grade_df)
#   student_col <- get_student_col(current_avg)
#   equal_or_above_75 <- logical(nrow(grade_df))
#   for (row in 1:nrow(grade_df)) {
#     max_col <- max(col(current_avg[row, ] & !is.na(grade_df[row, ])))
#     if (current_avg[row, max_col] >= 75) {
#       equal_or_above_75[row] <- TRUE
#     } else {
#       equal_or_above_75[row] <- FALSE
#     }
#   }
#   student_df <- add_student_col(current_avg, equal_or_above_75, 
#                                 student_col)
#   student_df
# }


```

```{r include = TRUE, echo = TRUE}
exam_fmt <- list(
  test = is_exam,
  wrap = TRUE,
  fill_pattern = as.integer(XLC$FILL.SOLID_FOREGROUND),
  foreground_color = as.integer(XLC$COLOR.GREY_25_PERCENT)
  )
final_fmt <- list(
  test = is_final,
  wrap = TRUE,
  fill_pattern = as.integer(XLC$FILL.SOLID_FOREGROUND),
  border = as.integer(XLC$BORDER.DOUBLE)
  )
below_65_fmt <- list(
  test = is_score_below_65,
  wrap = TRUE,
  fill_pattern = as.integer(XLC$FILL.SOLID_FOREGROUND),
  foreground_color = as.integer(XLC$COLOR.GREY_25_PERCENT)
  )




```